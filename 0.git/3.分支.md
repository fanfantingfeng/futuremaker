在GIt中提交时，会保存一个提交 (commit) 对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关的附属信息，包含0个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的， 普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。

假设在工作目录中有三个文件，准备将它们暂存后提交。暂存操作会对每一个文件计算校验和，然后把当前版本的文件快照保存到Git仓库中，并将校验和加入暂存区域：
```bash
git add README test.rb LICENSE
git commit -m 'initial commit of my project'
```
当使用git commit新建一个提交对象前，Git会先计算每一个子目录的校验和，然后在Git仓库中将这些目录保存为树(tree)对象。之后Git创建的提交对象，除了包含相关提交信息外，还包含指向这个树对象(项目根目录)的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。
	作修改后再次提交，这次的提交对象会包含一个指向上次提交对象的指针。

Git中的分支，本质上仅仅是个指向commit对象的可变指针。Git会使用master作为分支的默认名字。 在若干次提交后，其实你已经有了一个指向最后一次提交对象的master分支，它在每次提交时都会自动向前移动。
**分支其实就是从某个提交对象往回看的历史**

Git是如何创建一个新的分支的？
创建新的分支指针。
比如新建一个testing分支，可以用 git branch命令：
```bash
git branch testing
```
这会在当前commit对象上新建一个分支指针。

Git是如何知道你当前在哪个分支上工作的呢？
Git保存着一个名为HEAD的特别指针，它是一个指向你正在工作中的本地分支的指针。
运行 git branch命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，因此我们依然还在master分支中工作。
![[HEAD指向当前所在分支.png]]
要切换到其他分支，可以执行 git checkout 命令。
```bash
git checkout testing
```
这样，HEAD就指向了testing分支。
这样的实现方式有什么好处呢？
```bash
vim test.rb
git commit -a -m 'made a change'
```
后台的提交结果：
![[每次提交后HEAD随着分支一起向前移.png]]
testing分支向前移动了一格，而master分支仍然指向原先git checkout时所在的commit对象。
```bash
git checkout master
```
![[HEAD在一次checkout后移动到了另一个分支.png]]
这条命令做了两件事：
它把HEAD指针移回到master分支，并把工作目录中的文件换成了master分支所指向的快照内容。
也就是说，现在开始所做的改动，将始于本项目中一个较老的版本。它的主要作用是将testing分支里作出的修改暂时取消，这样你可以向另一个方向进行开发。

```bash
vim test.rb
git commit -a -m 'made other changes'
```
现在项目提交历史产生了分叉，因为刚才我们创建了一个分支，转换到其中进行了一些工作，然后又回到原来的主分支进行了另外一些工作。这些改变分别孤立在不同的分支里：我们可以在不同分支里反复切换，并在时机成熟时把它们合并到一起。而所有这些工作，仅仅需要branch和checkout两条命令就能完成。
![[不同流向的分支历史.png]]

由于Git中的分支实际上仅是一个包含所指对象校验和(40个字符长度SHA-1字符)的文件，所以创建和销毁一个分支很容易。新建一个分支就是向一个文件写入41个字节（外加一个换行符）那么简单。

Git每次提交时都记录了parent对象，将来要合并分支时，寻找恰当的合并基础的工作其实已经很自然的在那里了，因此实现起来非常容易。


### 分支的新建与合并
https://www.w3cschool.cn/isrekq/6bxwgozt.html
