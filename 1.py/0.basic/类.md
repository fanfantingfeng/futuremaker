类提供了把数据和功能绑定在一起的方法.
创建新类时创建了新的对象类型, 从而能够创建该类型的新实例.
实例具有能维持自身状态的属性, 还具有能修改自身状态的方法(由所属类来定义)

Python的类只使用了很少的新语法和语义, 类似C++和Modula-3中类的结合体, 而且支持面向对象编程的所有标准特性: 类的继承机制支持多个基类, 派生的类能覆盖基类的方法, 类的方法能调用基类中的同名方法.
对象可包含任意数量和类型的数据, 和模块一样, 类也支持Python动态特性: 在运行时创建, 创建后还可以修改.

## 名称和对象
对象之间相互独立, 多个名称(甚至多个作用域内的多个名称)可以绑定到同一对象. 这在其他语言中通常被称为别名.
对于涉及可变对象(列表, 字典等)的Python代码的语义, 别名可能会产生意料之外的效果. 这样做, 通常是为了让程序受益, 因为别名在某些方面就像指针. 例如, 传递对象的代价很小, 因为实现只传递一个指针; 如果函数修改了作为参数传递的对象, 调用者就可以看到更改---无需像Pascal那样用两个不同的机制来传递.

## Python作用域和命名空间
namespace (命名空间) 是从名称到对象的映射.
大多数命名空间都使用Python字典实现, 但除非涉及到性能优化, 一般不关注这方面的问题, 而且将来也可能会改变这种方式.
命名空间的例子: 
- 内置名称集合(包括abs()函数以及内置异常的名称等);
- 一个模块的全局名称;
- 一个函数调用中的局部名称.
对象的属性集合也是命名空间的一种形式.
关于命名空间的一个重要知识点: **不同命名空间中的名称之间绝对没有关系**!
两个不同模块都可以定义maximize函数, 且不会造成混淆, 用户使用函数时在函数名前加上模块名.

点号之后的名称是**属性**, 例如表达式z.real中, real是对象z的属性.
严格来说, 对模块中名称的引用是属性引用: 表达式modname.funcname中, modname是模块对象, funcname是模块的属性.
模块属性和模块中定义的全局名称之间存在直接的映射: 它们共享相同的命名空间!

属性是只读的或可写的. 在后一种情况下, 可以对属性进行赋值.
属性模块是可写的: 你可以写入modname.the_answer = 42, 也可以使用del语句删除可写属性.

命名空间是在不同时刻创建的, 且拥有不同的生命周期.
内置名称的命名空间是在Python解释器启动时创建的, 永远不会被删除.
模块的全局命名空间在读取模块定义时创建; 通常, 模块的命名空间也会持续到解释器退出.
从脚本文件读取或交互式读取时, 由解释器顶层调用执行的语句是 \_\_main\_\_模块调用的一部分, 也拥有自己的全局命名空间.
内置名称实际上也在模块里, 即 builtins.

函数的局部命名空间在函数被调用时被创建, 并在函数返回或抛出未在函数内被处理的异常时, 被删除(遗忘). 当然, 每次递归调用都有自己的局部命名空间.

一个命名空间的**作用域**是Python代码中的一段文本区域, 从这个区域可直接访问该命名空间.
"可直接访问"的意思是, 该文本区域内的名称在被非限定引用时, 查找名称的范围, 是包含该命名空间在内的.

作用域虽然是被静态确定的, 但会被动态使用.
执行期间的任何时刻, 都会有3或4个"命名空间可直接访问"的嵌套作用域:
- 最内层作用域, 包含局部名称, 并首先在其中进行搜索;
- 那些外层闭包函数的作用域, 包含"非局部, 非全局"的名称, 从最靠内层的那个作用域开始, 逐层向外搜索;
- 倒数第二层作用域, 包含当前模块的全局名称;
- 最外层(最后搜索)的作用域, 是内置名称的命名空间.

如果一个名称被声明为全局, 则所有引用和赋值都将直接指向"倒数第二层作用域", 即包含模块的全局名称的作用域.
要重新绑定在最内层的作用域以外找到的变量, 可以使用 nonlocal 语句; 如果未使用 nonlocal声明, 这些变来那个将为只读.
(尝试写入这样的变量将在最内层作用域中创建一个新的局部变来那个, 而使得同名的外部变量保持不变)

通常, 当前局部作用域将引用当前函数的局部名称. 在函数之外, 局部作用域引用域全局作用域一致的命名空间: 模块的命名空间.
类定义在局部命名空间内再防止另一个命名空间.

**作用域是按字面文本确定的:**
>模块内定义的函数的全局作用域就是该模块的命名空间, 无论该函数从什么地方或以什么别名被调用.
>实际的名称搜索是在运行时动态完成的.
>目前Python朝着"编译时静态名称解析"的方向发展, 因此不能过于依赖动态名称解析.

Python有一个特殊规定:
如果不存在生效的global或nonlocal语句, 则对名称的赋值总是会进入最内层作用域.
赋值不会赋值数据, 只是将名称绑定到对象.
删除也是如此: del x 从局部作用域引用的命名空间中移除对x的绑定.
所有引入新名称的操作都是使用局部作用域: 尤其是import 语句和函数定义会在局部作用域中绑定模块或函数的名称.

global 语句用于表明特定变量在全局作用域里, 并应在全局作用域中重新绑定;
nonlocal 语句表明特定变量在外层作用域中, 并应在外层作用域中重新绑定.

#### 示例
```python
def scope_test():
	def do_local():
		spam = "local spam"
	def do_nonlocal():
		nonlocal spam
		spam = "nonlocal spam"
	def do_global():
		global spam
		spam = "global spam"

	spam = "Test spam"
	do_local()
	print("After local assignment:", spam)
	do_nonlocal()
	print("After nonlocal assignment:", spam)
	do_global()
	print("After global assignment:", spam)
scope_test()
print("In global scope:", spam)
```
以上代码的输出结果:
```txt
After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
```
注: **局部**赋值(默认状态) 不会改变scope_test对spam的绑定. nonlocal赋值会改变scope_test对spam的绑定, 而 global赋值会改变模块层级的绑定.
而且, global 赋值前没有spam的绑定.

## 类-初识
#### 类定义语法
最简单的类定义形式:
```python
class ClassName:
	<statement-1>
	...
	<statement-N>
```
与定义函数一样, 类定义必须先执行才能生效. (把类定义放在if语句分支或函数内部试试)
在实践中, 类定义内的语句通常都是函数定义, 也可以是其他语句.
类里的函数定义一般是特殊的参数列表, 这是由方法调用的约定规范所指明的.

当进入类定义时, 将创建一个新的命名空间, 并将其用作局部作用域. 因此, 所有对局部变量的赋值都是在这个新命名空间之内.

当正常离开类定义时, 将创建一个类对象.
这基本上一个围绕类定义所创建的命名空间的包装器; 在进入类定义之前有效的作用域将重新生效, 类对象将在这里与类定义头所给出的类名称进行绑定.

#### Class对象
类对象支持两种操作: 属性引用和实例化.
属性引用使用python中所有属性引用所使用的标准语法: obj.name.
有效的属性名称是类对象被创建时存在于类命名空间中的所有名称.
```python
class MyClass:
	"""A simple example class"""
	i = 12345

	def f(self):
		return "hello world!"
```
MyClass.i 和 MyClass.f就是有效的属性引用, 将分别返回一个整数和一个函数对象.
类属性也可以被赋值, 因此可以通过赋值来更改MyClass.i的值.
\_\_doc\_\_也是一个有效的属性, 将返回所属类的文档字符串.

类的实例化使用函数表示法. 
可以把类对象视为是返回该类的一个新实例的不带参数的函数.
```python
x = MyClass()
```
创建类的新实例并将此对象分配给局部变量x.
实例化操作("调用"类对象)会创建一个空对象. 许多类都希望创建的对象实例是根据特定初始状态定制的, 因此一个类可能会定义名为 \_\_init\_\_()的特殊方法:
```python
def __init__(self):
	self.data = []
```
当一个类定义了\_\_init\_\_()方法时, 类的实例化会自动为新创建的类实例发起调用\_\_init\_\_().
当然, \_\_init\_\_()方法还有一些参数用于实现更高的灵活性. 在这种情况下, 提供给类实例化运算符的参数将被传递给\_\_init\_\_().
```python
class Complex:
	def __init__(self, realpart, imagepart):
		self.r = realpart
		self.i = imagepart

x = Complex(3,0, -4,5)
x.r, x.i
```

#### 实例对象
实例对象所能理解的唯一操作是属性引用. 
两种有效的属性名称:数据属性和方法.

数据属性对应于 Smalltalk中的"实例变量", 以及C++中的"数据成员".
数据属性不需要声明; 就像局部变来那个一样, 它们在首次被赋值时产生.
```python
x.counter = 1
while x.counter < 10:
	x.counter = x.counter * 2
print(x.counter)
del x.counter
```
另一种实例属性引用称为 **方法**, 方法是从属于对象的函数.
实例对象的有效方法名称依赖于其所属的类. 根据定义, 一个类中所有是函数对象的属性都是定义了其实例的相应方法.
x.f 是有效的方法引用, 因为 MyClass.f 是一个函数.
但x.f与MyClass.f并不是一回事, x.f是一个方法对象, 而不是函数对象.

#### 方法对象
https://docs.python.org/zh-cn/3/tutorial/classes.html
