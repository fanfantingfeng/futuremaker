# 列表
### 列表的所有方法
| 方法                                     | 说明                                                |
| -------------------------------------- | ------------------------------------------------- |
| list.append(x)                         | 在列表末尾添加一个元素。<br> 相当于a\[len(a):] = \[x]            |
| list.extend(iterable)                  | 用可迭代对象的元素扩展列表。<br> 相当于a\[len(a):] = iterable      |
| list.insert(i, x)                      | 在指定位置插入元素。<br> a.insert(len(a),x) 等同于a.append(x)  |
| list.remove(x)                         | 从列表中删除第一个值为x的元素。<br> 未找到元素则引发ValueError异常。        |
| list.pop(\[i])                         | 移除列表中给定位置上的条目，并返回该条目。<br> a.pop()移除并返回最后一个条目。     |
| list.clear()                           | 删除列表中所有元素。<br> 相当于del a\[:]                       |
| list.index(x\[, start\[, end]])        | 返回列表中第一个值为x的元素的零基索引。<br> 未找到指定元素时，触发ValueError异常。 |
| list.count(x)                          | 返回列表中元素x出现的次数。                                    |
| list.sort(\*, key=None, reverse=False) | 就地排序列表中的元素。<br> 详见 sorted()来了解自定义排序参数。            |
| list.reverse()                         | 翻转列表中的元素。                                         |
| list.copy()                            | 返回列表的浅拷贝。<br> 相当于a\[:]                            |

注：insert ,remove或sort等仅修改列表的方法都不会打印返回值，它们返回默认值None。
这是适用于Python中所有可变数据结构的设计原则。
**并非所有数据都可以排序或比较**，像\[None, 'hello', 10]就不可排序。

### 列表实现堆栈
通过列表方法可以非常容易地将列表作为栈来使用，最后添加的元素将最先被提取(后进先出)。
向栈顶添加一个条目，使用append();
从栈顶提取一个条目，使用pop()，无需显式指定索引。
```python
stack = [3, 4, 5]
stack.append(6)
stack.pop()
stack.pop()
```
### 列表实现队列
最先加入的元素，最先取出(先进先出)；但是列表作为队列的效率很低。
在列表末尾增减元素非常快，但在列表开头插入或移除元素却很慢(这样所有元素都必须移动一位)。
实现队列最好用 collections.deque, 可以快速从两端增减元素：
```python
from collections import deque
queue = deque(["Eric", "John", "Michael"])
queue.append("Terry")
queue.append("Graham")
queue.popleft()
```
### 列表推导式
列表推导式创建列表的方式更加简单。
常见的用法：对序列或可迭代对象中的每个元素应用某种操作，用生成的结果创建新的列表；或用满足特定条件的元素创建子序列。
```python
squares = []
for x in range(10):
	squares.append(x**2)
#上面的代码在创建列表后， x变量在循环结束后仍然存在。
#推导式
squares = list(map(lambda x: x**2, range(10)))
```
列表推导式可以无副作用地计算平方列表。
更推荐的一种简洁写法：
```python
squares = [x**2 for x in range(10)]
```
列表推导式的方括号包含以下内容：
- 一个表达式，后面为一个for子句，然后，是0个或多个for或if字句。
- 结果是由表达式依据for和if子句求值计算而的出一个新列表。
```python
[(x, y) for x in [1,2,3] for y in [3, 1, 4] if x != y]
```
等价于：
```python
combs = []
for x in [1,2,3]:
	for y in [3,1,4]:
		if x != y:
			combs.append((x,y))
```

列表推导式可以使用复杂的表达式和嵌套函数：
```python
from math import pi
[str(round(pi, i)) for i in range(1, 6)]
```
##### 嵌套的列表推导式
列表推导式中的初始表达式可以是任何表达式，甚至可以是另一个列表推导式。
```python
matrix = [
	[1, 2, 3, 4],
	[5, 6, 7, 8],
	[9, 10, 11, 12],
]
```
转置行列：
```python
[[row[i] for row in matrix] for i in range(4)]
```
在实际应用中，最好用内置函数替代复杂的流程语句。
zip()函数在此场景中更好用：
```python
list(zip(*matrix))
```

# del语句
del语句可以按索引从列表中移除内容。这与返回一个值的pop()方法不同。
del语句也可用于从列表中移除切片或清空整个列表。
```python
del a[2:4]
del a[:]
```
del也可以用来删除整个变量
```python
del a
```

# 元组和序列
列表和字符串都是 序列。 元组也是一种序列。
元组由多个用逗号隔开的值组成：
```python
t = 12345,54321,'hello!'
u = t, (1,2,3,4,5)
```
输出时，元组都要由圆括号标注，这样才能正确地解释嵌套元组。
元组的内容是不可变的。
```python
t[0] = 888
#将引发TypeError报错
```
元组的使用场景不同， 用途也与列表不同。
元组是 immutable(不可变的)，一般可包含异质元素序列，通过解包或索引访问(如果是namedtuples， 可以属性访问)。
列表是mutable,列表元素一般为同质类型，可迭代访问。

构造0个或1个元素的元组较为特殊，为了适应这种情况，对句法有一些额外的改变。
用一对空圆括号可以创建空元组；只有一个元素的元组可以通过在这个元素后添加逗号来构建。
虽然不好看，但是有效：
```python
empty_tuple = ()
single_tuple = 5, 
```
语句 t = 12345, 54321, 'hello'  是元组打包的例子：3个值被一起打包进元组。逆操作也可以：
```python
x, y, z= t
print(x, y, z)
```
也可以称之为 *序列解包*， 适用于右侧的任何序列。
序列解包时，左侧变量与右侧序列元素的数量应相等。
**注： 多重赋值其实只是元素打包和序列解包的组合。**

# 集合
集合是由不重复元素组合的无序容器。
基本用法包括成员检测、消除重复元素。
集合对象支持合集、交集、差集、对称差分等数学运算。
创建集合用花括号或set()函数。
注：创建空集合只能用set(), 不能用{}, {}创建的是空字典。
```python
basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
print(basket)
'orange' in basket   #True
'crabgrass' in basket  #False
a = set('abracadabra')
empty_s = set()
```
集合也支持推导式：
```python
a = {x for x in 'abcde' if x not in 'abc'}
```

# 字典
字典在其他语言中被称为"关联存储"或”关联数组“。
字典是以键进行索引， 键可以是任何不可变类型：字符串和数字总是可以作为键。
如果一个元组只包含字符串、数字或元组则也可以作为键；如果元组间接包含任何可变对象，则不能作为键。
列表不能作为字典的键。

{} 用于创建空字典，也可以在花括号中输入逗号分隔的键值对来生成字典。
https://docs.python.org/zh-cn/3/tutorial/datastructures.html
